// This file is copied and modified from The LLVM Compiler Infrastructure, which
// is distributed under the Apache License v2.0 with LLVM Exceptions (see
// LICENSE.TXT for details). This file is licensed under the same license.

#include "MCTargetDesc/TempleMCTargetDesc.h"
#include "Temple.h"
#include "TempleTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "Temple-isel"

// Temple-specific code to select Temple machine instructions for
// SelectionDAG operations.
namespace {
class TempleDAGToDAGISel : public SelectionDAGISel {
public:
  static char ID;

  TempleDAGToDAGISel() = delete;

  explicit TempleDAGToDAGISel(TempleTargetMachine &TargetMachine)
      : SelectionDAGISel(ID, TargetMachine) {}

  StringRef getPassName() const override {
    return "Temple DAG->DAG Pattern Instruction Selection";
  }

  void Select(SDNode *Node) override;

  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                    std::vector<SDValue> &OutOps) override;

  bool SelectAddrFI(SDValue Addr, SDValue &Base);

  // Include the pieces autogenerated from the target description.
#include "TempleGenDAGISel.inc"
};
} // namespace

char TempleDAGToDAGISel::ID = 0;

void TempleDAGToDAGISel::Select(SDNode *Node) {
  // If we have a custom node, we have already selected
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  SDLoc DL(Node);
  switch (Node->getOpcode()) {
  case ISD::FrameIndex: {
    SDValue Imm = CurDAG->getTargetConstant(0, DL, MVT::i16);
    int FI = dyn_cast<FrameIndexSDNode>(Node)->getIndex();
    EVT VT = Node->getValueType(0);
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
    
    ReplaceNode(Node, CurDAG->getMachineNode(Temple::ADDi, DL, VT, TFI, Imm));
    return;
  }
  case ISD::Constant: {
    ConstantSDNode *ConstNode = cast<ConstantSDNode>(Node);
    if (ConstNode->isZero()) {
      SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
                                           Temple::ZERO, MVT::i16);
      ReplaceNode(Node, New.getNode());
      return;
    } else if (ConstNode->isOne()) {
      SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
                                           Temple::ONE, MVT::i16);
      ReplaceNode(Node, New.getNode());
      return;
    } else if (ConstNode->isAllOnes()) {
      SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
                                           Temple::ALLONE, MVT::i16);
      ReplaceNode(Node, New.getNode());
      return;
    } else {
      SDValue New = CurDAG->getTargetConstant(ConstNode->getSExtValue(),
                                              SDLoc(Node), MVT::i16);
      ReplaceNode(Node, New.getNode());
      return;
    }
  }
  case TempleISD::RET: {
    ReplaceNode(Node,
                CurDAG->getMachineNode(Temple::RET, DL, Node->getValueType(0),
                                       Node->getOperand(0)));
    return;
  }

    // case ISD::CopyToReg:
    //   if (Node->getOperand(1)==Temple::ACC){

    //   }
  default:
    // Select the default instruction.
    SelectCode(Node);
    break;
  }
  //   if (Node->getOpcode() == ISD::BR) {
  //     SDLoc DL(Node);
  //     SDValue Imm = CurDAG->getTargetConstant(0, DL, MVT::i16);
  //     // int FI = dyn_cast<FrameIndexSDNode>(Node)->getIndex();
  //     EVT VT = Node->getValueType(0);
  //     // SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
  //     MachineRegisterInfo &MRI = MF->getRegInfo();
  //     Register GPR = MRI.createVirtualRegister(&Temple::GPROutRegClass);
  //     ReplaceNode(Node, CurDAG->getMachineNode(Temple::JLAlways, DL, VT,
  //     Imm)); return;
  //   }
}

bool TempleDAGToDAGISel::SelectInlineAsmMemoryOperand(
    const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
  switch (ConstraintID) {
  case InlineAsm::Constraint_i:
  case InlineAsm::Constraint_m:
    // We just support simple memory operands that have a single address
    // operand and need no special handling.
    OutOps.push_back(Op);
    return false;
  default:
    break;
  }

  return true;
}

bool TempleDAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
  if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
    return true;
  }
  return false;
}

// This pass converts a legalized DAG into a Temple-specific DAG, ready
// for instruction scheduling.
FunctionPass *llvm::createTempleISelDag(TempleTargetMachine &TM) {
  return new TempleDAGToDAGISel(TM);
}
